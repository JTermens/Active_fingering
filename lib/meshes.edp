// Packages for advanced remeshing scheme
load "Curvature"
load "distance"
load "isoline"
load "gsl"

func real[int,int] computeArchlength(real[int,int] b0, int n0, int i0, int i1){
  real[int,int] b1(3,n0);
  b1(0,:) = b0(0,:); b1(1,:) = b0(1,:);
  b1(2,i0) = 0;
  for (int i=i0+1; i<i1; i++){
    b1(2,i) = b1(2,i-1) + dist((b1(0,i)-b1(0,i-1)),(b1(1,i)-b1(1,i-1)));
  }
  return b1;
}

func real[int,int] twinPerioPoints(real [int,int] b0, int n0, real yTwin){
  real[int,int] b1(3,n0);
  for (int i=0; i<n0; i++){
    b1(0,(n0-1)-i) = b0(0,i); b1(1,(n0-1)-i) = yTwin;
  }
  return computeArchlength(b1,n0,0,n0);
}

func real[int,int] linInterpX(real x0, real x1, real y0, int n){
  real [int,int] b(2,n);
  real lb = x1-x0;
  for (int i=0; i<n; i++){
    real xi = x0 + lb*(real(i)/(n-1));
    b(0,i) = xi;
    b(1,i) = y0;
  }

  return b;
}

func mesh meshSemiplaneSinusoidal(
  int obd, int ibd, real bLayerThickness, real Lx, real Ly, real Amp, real q, int[int] labels 
){

  int labelBottom = labels[0];  // 1st periodic boundary (Bottom)
  int labelTop = labels[1];     // 2nd periodic boundary (Top)
  int labelRight = labels[2];   // Free boundary (right)
  int labelLeft = labels[3];    // Fixed boundary, opposed to the free one (left)

  real xMaxBnd = Amp*cos(q*Ly);

  // Defien the borders for both the bulk and the layer meshes
  border Bottom(t=0, 1){
    x = -Lx+(Lx+xMaxBnd-bLayerThickness)*t; 
    y = -Ly;
    label = labelBottom;
  }
  border BottomLayer(t=0, 1){
    x = xMaxBnd-bLayerThickness*(1-t);
    y = -Ly;
    label = labelBottom/*L*/;
  }

  border Top(t=0, 1){
    x = xMaxBnd-bLayerThickness-(Lx-bLayerThickness+xMaxBnd)*t; y = Ly; 
    label = labelTop;
  }
  border TopLayer(t=0, 1){
    x = xMaxBnd-bLayerThickness*t;
    y = Ly;
    label = labelTop/*L*/;
  }

  border Left(t=0,1){
    x = -Lx;
    y = Ly*(1-2*t);
    label = labelLeft;
  }

  // change for a perturbed front, if needed. Mantain extreme points at x=0
  border Right(t=0,1){
    x = 0+Amp*cos(q*Ly*(2*t-1));
    y = Ly*(2*t-1);
    label = labelRight;
  }
  // border Inner(t=0,1){
  //   x = -bLayerThickness+Amp*cos(q*Ly*(2*t-1));
  //   y = Ly*(2*t-1);
  // }

  mesh Th = buildmesh(
    Bottom(ibd*(Lx-bLayerThickness))
    + BottomLayer(obd*bLayerThickness)
    + Right(obd*2.*Ly)
    /*+ Inner(obd*2.*Ly)*/
    + TopLayer(obd*bLayerThickness)
    + Top(ibd*(Lx-bLayerThickness))
    + Left(ibd*2.*Ly)
  );

  // Th = change(Th,rmInternalEdges=1);

  return Th;
}

func mesh periodicRemesh1FreeBnd(
  mesh Th0,int obd, int ibd, real bLayerThickness, real smoothCoef, int[int] labels
){

  int[int] labelPerio = [labels[0],labels[1]]; // Periodic boundaries
  int labelFree = labels[2];   // Free boundary
  int labelFixed = labels[3];  // Fixed boundary, opposed to the free one

  int[int] be(1); // To save begin and ends of the layer curve
  int minPoints = 5;
  real eps = pow(10,-9);

  // Extract the non-periodic boundary pieces
  real[int,int] bFree(3,1); real lFree = extractborder(Th0,labelFree,bFree);             // extract free
  real[int,int] bFixed(3,1); real lFixed = extractborder(Th0,labelFixed,bFixed);         // extract fixed

  // ------------------------------------------------------------------------------------
  // Define an inner border that defines the boundary layer through isolines
  
  real xLayer = 0;
  // Find the extreme points of the periodic boundaries
  real[int] pointsXPerio = [bFixed(0,bFixed.m-1), xLayer, bFree(0,0)];
  real[int] pointsYPerio = [bFixed(1,bFixed.m-1), bFixed(1,0)];

  mesh Th = Th0;
  fespace Dh(Th, P1);

  // Distance function (d is the minimal distance to the boundary)
  varf vong(B, d)= on(labelFree,B=1);
  real[int] ong=vong(0,Dh);
  Dh B =1, d;
  B[] = ong ? 0 : B[];
  distance(Th,B,d[]);
  // plot(Th, d wait=1);

  // Get the new inner boundary vertices (bLayer is the contour d==bLayerThickness)
  real[int,int] bLayer(3,1); int nLayer=isoline(Th,d,iso=bLayerThickness,close=0,bLayer,beginend=be);
  
  int nInnerLines = be.n/2;
  // cout << be << endl;

  int[int] nInner(nInnerLines); // numer of points per loop
  int nCorrectLines = 0; // number of loops with more than minPoints
  // find number of points and count > minPoints & correct open ends
  for (int i=0;  i < nInnerLines; i++){

    real lInner = bLayer(2,be(i*2+1)-1);
    nInner[i] = lround(obd*lInner);
    if(nInner[i] > minPoints){nCorrectLines++;}

    if(dist((bLayer(0,be(i*2+1)-1)-bLayer(0,be(i*2))),(bLayer(1,be(i*2+1)-1)-bLayer(1,be(i*2)))) > eps){ // Open loop
      bLayer(1,be(i*2)) = pointsYPerio[0]; // correct y-coords
      bLayer(1,be(i*2+1)-1) = pointsYPerio[1];

      nLayer = be(i*2+1)-be(i*2); // # points in the layer's isoline
      xLayer = bLayer(0,be(i*2)); // x-coord of the layer
      bLayer(0,be(i*2+1)-1) = xLayer; // correct x-coords

      bLayer = computeArchlength(bLayer,bLayer.m,be(2*i),be(2*i+1));
    }
  }
  
  // if the number of points is less than minPoints, filter the border for safety
  int[int] nInnerF(nCorrectLines);
  int[int] beF(2*nCorrectLines);

  for (int i=0;  i < nInnerLines; i++){
    if(nInner[i] > minPoints){
      nInnerF[i] = nInner[i];
      beF[2*i] = be[i*2];
      beF[2*i+1] = be[i*2+1];
    }
  }
  
  border Inner(t=0,1;i) {P=Curve(bLayer,beF(i*2),beF(i*2+1)-1,t);} // Inner boundary multi-border
  // cout << nInner << endl;
  // ------------------------------------------------------------------------------------------------------------------
  
  // Find the extreme points of the periodic boundaries
  pointsXPerio[1] = xLayer;
  // cout << pointsXPerio << endl;

  // We take extremaXPerio as the x-cords of the periodic bnds extremes
  // and extremaYPerio as their y-coords 

  // Chechk the free-perio2 junction point
  if (abs(bFree(0,0)-bFree(0,bFixed.m-1)) > eps){
    bFree(0,bFree.m-1) = bFree(0,0); // Correct the x-coord in order to match the points
    bFree(2,bFree.m-1) = bFree(2,bFree.m-2) + dist(
      bFree(0,bFree.m-1)-bFree(0,bFree.m-2),
      bFree(1,bFree.m-1)-bFree(1,bFree.m-2)
    ); // Update arch-length
  }

  // Remesh the free boundary using an spline
  gslspline splineXFree(gslinterpakimaperiodic, bFree(2, :), bFree(0, :)); 	// x(s) akima spline
  gslspline splineYFree(gslinterpakimaperiodic, bFree(2, :), bFree(1, :)); 	// y(s) akima spline

  int nFree = round(obd*lFree);	// new number of elements (prescribed density obd)
  border Free(t=0,lFree){
    x = splineXFree(t);
    y = splineYFree(t);
    label = labelFree;
  }

  // Keep the same vertices for the fixed
  int nFixed = bFixed.m-1;
  border Fixed(t=0,1){
    P = Curve(bFixed,bFixed(2,lround(t*nFixed))/lFixed);
    label = labelFixed;
  }

  // Define the periodic boundaries by linear interpolation
  real lPerioB = pointsXPerio[1]-pointsXPerio[0];
  real lPerioL = pointsXPerio[2]-pointsXPerio[1];
  int nPerioB = lround(ibd*lPerioB);
  int nPerioL = lround(obd*lPerioL);
  
  real[int,int] bPerioB = computeArchlength(linInterpX(pointsXPerio[0],pointsXPerio[1],pointsYPerio[0],nPerioB),nPerioB,0,nPerioB);
  real[int,int] bPerioL = computeArchlength(linInterpX(pointsXPerio[1],pointsXPerio[2],pointsYPerio[0],nPerioL),nPerioL,0,nPerioL);

  // real[int,int] bPerio1B = twinPerioPoints(bPerio0B,pointsYPerio[1],nPerioB);
  // real[int,int] bPerio1L = twinPerioPoints(bPerio0L,pointsYPerio[1],nPerioL);

  // Tried with diferent options, using splines  is the most robust
  gslspline splineXPerioB(gslinterpakimaperiodic, bPerioB(2, :), bPerioB(0, :)); 	// x(s) akima spline
  gslspline splineXPerioL(gslinterpakimaperiodic, bPerioL(2, :), bPerioL(0, :)); 	// x(s) akima spline

  border Perio0B(t=0,lPerioB){
    label = labelPerio[0];
    x = splineXPerioB(t); y = pointsYPerio[0];
  }

  border Perio0L(t=0,lPerioL){
    label = labelPerio[0];
    x = splineXPerioL(t); y = pointsYPerio[0];
  }
  
  border Perio1B(t=lPerioB,0){
    label = labelPerio[1];
    x = splineXPerioB(t); y = pointsYPerio[1];
  }

  border Perio1L(t=lPerioL,0){
    label = labelPerio[1];
    x = splineXPerioL(t); y = pointsYPerio[1];
  }

  // plot(
  //   Perio0B(nPerioB) + Perio0L(nPerioL) + Perio1B(nPerioB) + Perio1L(nPerioL) 
  //   + Free(nFree) + Fixed(nFixed) /*+ Inner(nInnerF)*/, wait=1
  // );

  Th = buildmesh(
    Perio0B(nPerioB) 
    + Perio0L(nPerioL) 
    + Perio1B(nPerioB) 
    + Perio1L(nPerioL) 
    + Free(nFree) 
    + Fixed(nFixed) 
    + Inner(nInnerF)/*,
    fixedborder=1*/
  );

  Th = change(Th, rmInternalEdges=1);

  return Th;
}


// Construct the mesh -------------------------------------------------------------------------------------------------

// Common params
int obd = 35;
int ibd = 15;
real bLayerThickness = 0.4;
real Lx = 2;
real Ly = 2;
real Amp = 0.1;
real qBnd = 4*pi;

int[int] labels = [1,3,2,4];

mesh Th = meshSemiplaneSinusoidal(obd,ibd,bLayerThickness,Lx,Ly,Amp,qBnd,labels);

// Extract outer boundary
// extractborder gives bOut(3,Th.nbe+1) with 1st point == last point
// for k in (0,Th.nbe-1): 
//		bOut(0,k) == x coord kth vertex
//		bOut(1,k) == y coord kth vertex
//		bOut(2,k) == arch length at the kth vertex
// real[int,int] bMesh(3,1); real lMesh = extractborder(Th, labelBnd, bMesh);

plot(Th, wait=1);

Th = periodicRemesh1FreeBnd(Th,obd,ibd,bLayerThickness,.5,labels);
// Th = closedRemesh(bMesh,lMesh,bMesh.m-1,bLayerThickness,obd,ibd,labelBnd,.5,0,1); // Custom mesh adaptation

// Initial variables for shape characterization
real Area0 = Th.measure; // Inital Area of the Fluid Domain
real Xcm0 = int2d(Th)(x)/Area0; //Initial x_cm
real Ycm0 = int2d(Th)(y)/Area0; //Initial y_cm


plot(
  Th,value = true, fill = false, nbiso=64, wait=true, 
  cmm = "adaptive mesh;  A0="+Area0+",  (xcm0,yxm0)=("+Xcm0+","+Ycm0+")"
);

func perio=[[labels[0],x],[labels[1],x]]; // Periodicity

real finalAmp = .4;
int NiterTime = 100;
real dt = finalAmp/NiterTime;

int nDfm = 1;
fespace Vel(Th,[P1b,P1b], periodic=perio); // For the deformation velocity

macro v [v1, v2]  // Velocity field
macro u [u1, u2]	// Velocity test function


// Iterate time
for (int iterTime=0 ; iterTime<NiterTime ; iterTime++) {
  cout << iterTime << endl;
  // Define a test velocity at the boundary (null in the bulk)
  varf bndDirichlet(v, u) = on(labels[2], v1 = 1.*cos(qBnd*y))/*+on(labels[3], v1 = -2*cos(y*(2.*pi)))*/;
  Vel v=[0,0];
  v1[] = bndDirichlet(0, Vel, tgv = 1.0);

	// Move mesh10
	// real minT0 = checkmovemesh(Th, [x, y]); // to check for flipped triangles
	// real minT = checkmovemesh(Th, [x+dt*V1,y+dt*V2]);
	// cout << "Min triangle area before: "+minT0+" & after: "+minT<<endl;
	Th = movemesh(Th,[x+dt*v1,y+dt*v2]);

  // Remesh
  Th = periodicRemesh1FreeBnd(Th,obd,ibd,bLayerThickness,.5,labels);
  
  plot(Th,[v1,v2], wait=false, cmm="Time = "+(1+iterTime)*dt);
}

//---------------------------------------------------------------------------------------------------------------------
