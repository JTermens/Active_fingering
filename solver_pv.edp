// PACKAGES FOR ADVANCED REMESHING SCHEME
load "Curvature"
load "distance"
load "isoline"
load "gsl"

// Testing

//include <iostream>;
// include "/home/joan/Documents/Tesi_doct/Spontaneous_tissue_motility/Simul_runs/large_clusters_MDCK/parameters_MDCK_MCF10a_Blanch.edp";
include "/home/joan/Documents/Repositoris/Spontaneous_tissue_motility/parameters_sets/parameters_MDA-Mb-231_Alert.edp";

string SimulName;
string pathDir;

for (int i=0; i<nSimul; i++){
  SimulName = SimulNames[i];
	real cut = cuts[i];
	real R0 = R0s[i];

  if (bsave){
    pathDir = pathDirs[i];
  }

  // Problem Parameters
  real a = abs(zeta)/(zi*Lc); 	    		// Active |zeta|/zi and Nematic length ratio
  real b = R0*R0*xi/eta;	              // R0 and hydrodynamic length sqrt(eta/xi) ratio
  real c = R0/Lc;  		 		 		          // R0 and nematic length ratio


  cout << "Simul: " << SimulName << ", saving = " << bsave << "\nR0 = " << R0 /*<< ", Rc = " << Rc*/
<< ", lambda = " << sqrt(eta/xi) << ", Lc = " << Lc << ", La = " << abs(zeta)/zi << ", tscale = " << tscale << endl;


  // Perturbations of the circular domain with 1 cut, smoth with 1/f = 0
  mesh Th,Thb;

    real ThickOutMesh = Lc/R0;						// Thickness of the outer mesh
   	real Rarc = fracRarc;
    real t1 = acos((cos(cut/2.)-Rarc)/(1-Rarc));

   	real[int] OxPlus = [(1-Rarc)*cos(AxisCut[0]+t1)];
   	real[int] OyPlus = [(1-Rarc)*sin(AxisCut[0]+t1)];
   	real[int] OxMin = [(1-Rarc)*cos(AxisCut[0]-t1)];
   	real[int] OyMin = [(1-Rarc)*sin(AxisCut[0]-t1)];
   	real LenCut = sqrt((OxPlus[0]-OxMin[0])*(OxPlus[0]-OxMin[0]) + (OyPlus[0]-OyMin[0])*(OyPlus[0]-OyMin[0]));

    border GammaArchMin0(t=0,1){x=OxMin[0]+Rarc*cos(AxisCut[0]-t1*(1-t)); y=OyMin[0]+Rarc*sin(AxisCut[0]-t1*(1-t)); label=1;}
   	border GammaCut0(t=0,1){x=((OxMin[0]+Rarc*cos(AxisCut[0]))+(OxPlus[0]-OxMin[0])*t);
   													y=((OyMin[0]+Rarc*sin(AxisCut[0]))+(OyPlus[0]-OyMin[0])*t);label=1;}
   	border GammaArchPlus0(t=0,1){x=OxPlus[0]+Rarc*cos(AxisCut[0]+t1*t); y=OyPlus[0]+Rarc*sin(AxisCut[0]+t1*t); label=1;}
   	border GammaArch0(t=0,1){x=cos(AxisCut[0]+t1+2*(pi-t1)*t);
   													 y=sin(AxisCut[0]+t1+2*(pi-t1)*t);label=1;}

   	Th=buildmesh(GammaArchMin0(obd*Rarc*t1)
   							+GammaCut0(obd*LenCut)
   							+GammaArchPlus0(obd*Rarc*t1)
   							+GammaArch0(obd*2*(pi-t1))
   							);
/*
		mesh Th,Thb;

			real ThickOutMesh = Lc/R0;						// Thickness of the outer mesh

			border Gamma(t=0,2*pi){x=cos(t); y=sin(t); label=1;}
			Th = buildmesh(Gamma(2*pi*obd));
*/
    // Smooth the outer boundary pieces
    real[int,int] b1(3,1); real l1=extractborder(Th,1,b1); // l1 is the permiter of b1
    gslspline splineX(gslinterpakima, b1(2, :), b1(0, :)); 	// x(s) akima spline
    gslspline splineY(gslinterpakima, b1(2, :), b1(1, :)); 	// y(s) akima spline
    border Outer(t=0,l1){x=splineX(t);y=splineY(t);label=1;}
    int nO = round(obd*l1);
    // Transform the dense mesh & into an adaptive one
    fespace Dini(Th, P1);	// Distance function to define the contour region of the mesh

    varf vong(B, d)= on(1,B=1);
    real[int] ong=vong(0,Dini);
    Dini B =1, d;
    B[] = ong ? 0 : B[];
    distance(Th,B,d[]);

    // Get the new inner boundary vertices (ISO is the contour d==nu)
    real[int,int] ISO(3,1); int nc=isoline(Th,d,iso=ThickOutMesh,close=1,ISO,smoothing=ThickOutMesh/2.,ratio=1.e-0);
    real l2=ISO(2,ISO.m-1); // l2 is the perimeter of ISO
    border Inner(t=0,1){ P=Curve(ISO,t);label=0;}
    int nI = round(ibd*l2); 						// new number of elements (prescribed density ibd)

    // C. BUILD NEW MESH
    Th=buildmesh(Outer(nO)+Inner(nI),fixedborder=1);
    Th=change(Th,rmInternalEdges=1);
    Thb=emptymesh(Th);


  real Area0=Th.measure; // Inital Area of the Fluid Domain
  real Areai=Area0;
  real Xcm0=int2d(Th)(x)/Areai; //Initial x_cm
  real Ycm0=int2d(Th)(y)/Areai; //Initial y_cm
  real XcmP=Xcm0;
  real YcmP=Ycm0;
  real Xcm=Xcm0;
  real Ycm=Ycm0;

  if (verbosity) {
  	plot(Th,value = true, fill = false, nbiso=64, wait=true, cmm = "adaptive mesh;  A0="+Area0+",  (xcm0,yxm0)=("+Xcm0+","+Ycm0+")");
  }

  //FEM spaces
  fespace Pol(Th, [P2, P2]);					// For polarity vector
  fespace Pola(Th, P2 );							// For |p| (not essential, just visualization)
  fespace Vel(Th, [P1b, P1b]);				// For velocity vector
  fespace Dh(Th, P1);								  // For distance function (remeshing scheme) and data exports
  fespace Vor(Th,P1b);								// To compute the vorticity & divergence
  fespace Nh(Th,[P1,P1]);						  // For the corrected normal vector at the boundary

  //Macros
  macro pD [pD1, pD2]																// P2 extension for Dirichlet data
  macro p [p1, p2] 																	// Polarity vector field
  macro q [q1, q2] 																	// Polarity test functions
  macro V [V1, V2] 																	// Velocity field
  macro U [U1, U2] 																	// Velocity test functions
  macro grad(u) [dx(u),dy(u)]												// Gradient of a sclar
  macro Grad(u1,u2) [dx(u1),dy(u1),dx(u2),dy(u2)] 	// Gradient of a vector
  macro GradT(u1,u2) [dx(u1),dx(u2),dy(u1),dy(u2)] 	// Grad vector transpose
  macro pp(p1,p2) [p1*p1,p1*p2,p2*p1,p2*p2] 				// Active stress tensor

  // Correction of the normal vectors at the boundary
  int NbBoundaryElements = Th.nbe;
  int[int] bcon(NbBoundaryElements);
  real[int] xx(NbBoundaryElements+1),yy(NbBoundaryElements+1);
  for (int k = 0; k < NbBoundaryElements; k++){
           bcon[k] = Th.be(k)[0];
  	 xx[k]=Th(Th.be(k)[0]).x; yy[k]=Th(Th.be(k)[0]).y;
  }
  xx[NbBoundaryElements]=xx[0]; yy[NbBoundaryElements]=yy[0];

  Nh [nx,ny]; // here the Dof of nx,ny are scramble .
  nx[]=0;ny[]=0;

  real[int] nprev(2), npost(2), nmean(2);
  real lenprev, lenpost;
  nprev = [(yy[0]-yy[NbBoundaryElements-1]),-(xx[0]-xx[NbBoundaryElements-1])];
  lenprev = sqrt(pow(nprev[0],2)+pow(nprev[1],2));

  for (int k = 0; k < NbBoundaryElements; k++){
    npost = [(yy[k+1]-yy[k]),-(xx[k+1]-xx[k])];
    lenpost = sqrt(pow(npost[0],2)+pow(npost[1],2));

    nmean = nprev/(1+lenprev/lenpost) + npost/(1+lenpost/lenprev);
    nmean /= sqrt(pow(nmean[0],2)+pow(nmean[1],2));

  	nx[](2*bcon(k))= nmean[0]; ny[](2*bcon(k)+1) = nmean[1];
  	nprev = npost; lenprev = lenpost;
  }

  // P2 extension of polarity Dirichlet data
  varf bndDirichlet(pD, q) = on(1, pD1 = nx) + on(1, pD2 = ny);// + on(2, p1 = N.x) + on(2, p2 = N.y);
  Pol pD=[0,0];
  pD1[] = bndDirichlet(0, Pol, tgv = 1.0);

  if (verbosity) {
  	plot(pD1, value = true, fill = true, nbiso=64, wait=true, cmm = "pDx");
  	plot(pD2, value = true, fill = true, nbiso=64, wait=true, cmm = "pDy");
  }
  // Bilinear and linear variational forms P (Modified Homogeneous Drirchlet problem for p-pD)
  varf ap(p, q) = int2d(Th)(  grad(p1)'*grad(q1) + grad(p2)'*grad(q2) )  + int2d(Th)(c*c*(p'*q)) + on(1, p1 = 0.0) + on(1, p2=0.0);//+ on(2, p1=0.0) + on(2, p2=0.0);
  varf lp(p, q) = -int2d(Th)( grad(pD1)'*grad(q1) + grad(pD2)'*grad(q2) ) - int2d(Th)(c*c*(pD'*q))  + on(1, p1 = 0.0) + on(1, p2=0.0);//+ on(2, p1=0.0) + on(2, p2=0.0);

  // Assembly P
  matrix Ap = ap(Pol, Pol, tgv = -2); // LHS matrix
  real[int] bp = lp(0, Pol); // RHS

  // P solution with vanishing Dirichlet data
  real[int] solP(Pol.ndof);
  //set(Ap,solver=sparsesolver);
  solP=Ap^-1*bp;
  Pol p=[0,0];
  p1[]=solP(0:Pol.ndof-1);

  if (verbosity) {
  	plot(Th,p1, value = true, fill = true, nbiso=64, wait=true, cmm = "dpx = px-pDx");
  	plot(Th,p2, value = true, fill = true, nbiso=64, wait=true, cmm = "dpy = py-pDy");
  }

  // P solution
  p = p + pD;

  // Compute the divergence, curl and normal derivative of the polarity for the posterior analysis
  // Divergence
  varf aDivP(DivP, g) = int2d(Th)(DivP*g);
  varf lDivP(DivP, g) = int2d(Th)((dx(p1)+dy(p2))*g);

  matrix ADivP = aDivP(Vor, Vor);		// LHS matrix
  real[int] bDivP = lDivP(0, Vor);	// RHS vector

  real[int] solDivP(Vor.ndof);
  solDivP=ADivP^-1*bDivP;
  Vor DivP=solDivP(0:Vor.ndof-1);

  // Curl (Vorticity)
  varf aCurlP(CurlP, g) = int2d(Th)(CurlP*g);
  varf lCurlP(CurlP, g) = int2d(Th)((dx(p2)-dy(p1))*g);

  matrix ACurlP = aCurlP(Vor, Vor);		// LHS matrix
  real[int] bCurlP = lCurlP(0, Vor);	// RHS vector

  real[int] solCurlP(Vor.ndof);
  solCurlP=ACurlP^-1*bCurlP;
  Vor CurlP=solCurlP(0:Vor.ndof-1);

  if (verbosity) {
  	plot(Th,p1, value = true, fill = true, nbiso = 64, wait = true, cmm = "px");
  	plot(Th,p2, value = true, fill = true, nbiso = 64, wait = true, cmm = "py");
  	plot(Th,p, value = true, fill = true, nbiso = 64, wait = true, cmm = "(px,py)");
  	// Abs(P)
  	Pola pABS = sqrt(p1(x,y)^2 + p2(x,y)^2);
  	plot(Th,pABS, value = true, fill = true, nbiso = 64, wait = true, cmm = "|p|");
  	plot(Th,DivP, value = true, fill = true, nbiso = 64, wait = true, cmm = "Div(P)");
  	plot(Th,CurlP, value = true, fill = true, nbiso = 64, wait = true, cmm = "Curl(P)");
  }

  // Bilinear and linear variational forms V
  varf av(V, U) = int2d(Th)( ((Grad(V1,V2)+GradT(V1,V2))'*Grad(U1,U2)) )  + int2d(Th)( b*(V'*U) ); // -viscosity -friction
  varf lv(V, U) = int2d(Th)( -a*(pp(p1,p2)'*Grad(U1,U2)) ) + int2d(Th)( c*(p'*U) ); //contractility +active traction

  // Assembly V
  matrix Av = av(Vel, Vel);
  real[int] bv = lv(0, Vel);

  // V solution
  real[int] solV(Vel.ndof);
  //set(Av,solver=sparsesolver);
  solV=Av^-1*bv;
  Vel V=[0,0];
  V1[]=solV(0:Vel.ndof-1);

  // Compute divergence and curl of the velocity for the posterior analysis
  // Divergence
  varf aDivV(DivV, g) = int2d(Th)(DivV*g);
  varf lDivV(DivV, g) = int2d(Th)((dx(V1)+dy(V2))*g);

  matrix ADivV = aDivV(Vor, Vor);		// LHS matrix
  real[int] bDivV = lDivV(0, Vor);	// RHS vector

  real[int] solDivV(Vor.ndof);
  solDivV=ADivV^-1*bDivV;
  Vor DivV=solDivV(0:Vor.ndof-1);

  // Curl (Vorticity)
  varf aCurlV(CurlV, g) = int2d(Th)(CurlV*g);
  varf lCurlV(CurlV, g) = int2d(Th)((dx(V2)-dy(V1))*g);

  matrix ACurlV = aCurlV(Vor, Vor);		// LHS matrix
  real[int] bCurlV = lCurlV(0, Vor);	// RHS vector

  real[int] solCurlV(Vor.ndof);
  solCurlV=ACurlV^-1*bCurlV;
  Vor CurlV=solCurlV(0:Vor.ndof-1);

  if (verbosity) {
  	plot(Th,V1, value = true, fill = true, nbiso = 64, wait = true, cmm = "vx");
  	plot(Th,V2, value = true, fill = true, nbiso = 64, wait = true, cmm = "vy");
  	plot(Th,V, value = true, fill = true, nbiso = 64, wait = true, cmm = "(vx,vy)");
  	// Abs(P)
  	Pola vABS = sqrt(V1(x,y)^2 + V2(x,y)^2);
  	plot(Th,vABS, value = true, fill = true, nbiso = 64, wait = true, cmm = "|V|");
  	plot(Th,DivV, value = true, fill = true, nbiso = 64, wait = true, cmm = "Div(V)");
  	plot(Th,CurlV, value = true, fill = true, nbiso = 64, wait = true, cmm = "Curl(V)");
  }

  if(bsave){
  	{ ofstream fileTimeSeries (pathDir+"/timeSeries.csv");
  			fileTimeSeries	<< "Time,Area,Xcm,Ycm,Vxcm,Vycm,Pxcm,Pycm,DivTermsX,DivTermsY"<<endl;
  	}
  }

  // Iterate time
  for (int iterTime=0 ; iterTime<NiterTime ; iterTime++) {

  	if (iterTime % 100 == 0 && iterTime > 0) {
  		cout << iterTime << " out of " << NiterTime << " iterations completed" << endl;
  	}

  	// Correction of the normal vectors at the boundary
  	int NbBoundaryElements = Th.nbe;
  	int[int] bcon(NbBoundaryElements);
  	real[int] xx(NbBoundaryElements+1),yy(NbBoundaryElements+1);
  	for (int k = 0; k < NbBoundaryElements; k++){
  	         bcon[k] = Th.be(k)[0];
  		 xx[k]=Th(Th.be(k)[0]).x; yy[k]=Th(Th.be(k)[0]).y;
  	}
  	xx[NbBoundaryElements]=xx[0]; yy[NbBoundaryElements]=yy[0];

  	Nh [nx,ny]; // here the Dof of nx,ny are scramble .
  	nx[]=0;ny[]=0;

    real[int] nprev(2), npost(2), nmean(2);
	  real lenprev, lenpost;
	  nprev = [(yy[0]-yy[NbBoundaryElements-1]),-(xx[0]-xx[NbBoundaryElements-1])];
	  lenprev = sqrt(pow(nprev[0],2)+pow(nprev[1],2));

	  for (int k = 0; k < NbBoundaryElements; k++){
	    npost = [(yy[k+1]-yy[k]),-(xx[k+1]-xx[k])];
	    lenpost = sqrt(pow(npost[0],2)+pow(npost[1],2));

	    nmean = nprev/(1+lenprev/lenpost) + npost/(1+lenpost/lenprev);
	    nmean /= sqrt(pow(nmean[0],2)+pow(nmean[1],2));

	  	nx[](2*bcon(k))= nmean[0]; ny[](2*bcon(k)+1) = nmean[1];
	  	nprev = npost; lenprev = lenpost;
	  }

  	// P2 extension of polarity Dirichlet data
  	varf bndDirichlet(pD, q) = on(1, pD1 = nx) + on(1, pD2 = ny);// + on(2, p1 = N.x) + on(2, p2 = N.y);
  	Pol pD=[0,0];
  	pD1[] = bndDirichlet(0, Pol, tgv = 1.0);

  	// Assembly P
  	varf lp(p, q) = -int2d(Th)( grad(pD1)'*grad(q1) + grad(pD2)'*grad(q2) ) - int2d(Th)(c*c*(pD'*q))  + on(1, p1 = 0.0) + on(1, p2=0.0);
  	matrix Ap = ap(Pol, Pol, tgv = -2); 	// LHS matrix
  	real[int] bp = lp(0, Pol); 			// RHS

  	// P solution with vanishing Dirichlet data
  	real[int] sol(Pol.ndof);
  	//set(Ap,solver=sparsesolvenetr);
  	sol=Ap^-1*bp;
  	Pol p=[0,0];
  	p1[]=sol(0:Pol.ndof-1);

  	// P solution
  	p = p + pD;

  	// Compute the divergence and curl of the velocity for the posterior analysis
  	// Divergence
  	varf aDivP(DivP, g) = int2d(Th)(DivP*g);
  	varf lDivP(DivP, g) = int2d(Th)((dx(p1)+dy(p2))*g);

  	matrix ADivP = aDivP(Vor, Vor);		// LHS matrix
  	real[int] bDivP = lDivP(0, Vor);	// RHS vector

  	real[int] solDivP(Vor.ndof);
  	solDivP=ADivP^-1*bDivP;
  	Vor DivP=solDivP(0:Vor.ndof-1);

  	// Curl (Vorticity)
  	varf aCurlP(CurlP, g) = int2d(Th)(CurlP*g);
  	varf lCurlP(CurlP, g) = int2d(Th)((dx(p2)-dy(p1))*g);

  	matrix ACurlP = aCurlP(Vor, Vor);		// LHS matrix
  	real[int] bCurlP = lCurlP(0, Vor);	// RHS vector

  	real[int] solCurlP(Vor.ndof);
  	solCurlP=ACurlP^-1*bCurlP;
  	Vor CurlVP=solCurlP(0:Vor.ndof-1);

  	// Assembly V
  	varf lv(V, U) = int2d(Th)( -a*(pp(p1,p2)'*Grad(U1,U2)) ) + int2d(Th)( c*(p'*U) ); //contractility + active traction
  	matrix Av = av(Vel, Vel);  			// LHS matrix
  	real[int] bv = lv(0, Vel);			// RHS

  	// V solution
  	real[int] solV(Vel.ndof);
  	//set(Av,solver=sparsesolver);
  	solV=Av^-1*bv;
  	Vel V=[0,0];
  	V1[]=solV(0:Vel.ndof-1);

  	// Compute the divergence and curl of the velocity for the posterior analysis
  	// Divergence
  	varf aDivV(DivV, g) = int2d(Th)(DivV*g);
  	varf lDivV(DivV, g) = int2d(Th)((dx(V1)+dy(V2))*g);

  	matrix ADivV = aDivV(Vor, Vor);		// LHS matrix
  	real[int] bDivV = lDivV(0, Vor);	// RHS vector

  	real[int] solDivV(Vor.ndof);
  	solDivV=ADivV^-1*bDivV;
  	Vor DivVV=solDivV(0:Vor.ndof-1);

  	// Curl (Vorticity)
  	varf aCurlV(CurlV, g) = int2d(Th)(CurlV*g);
  	varf lCurlV(CurlV, g) = int2d(Th)((dx(V2)-dy(V1))*g);

  	matrix ACurlV = aCurlV(Vor, Vor);		// LHS matrix
  	real[int] bCurlV = lCurlV(0, Vor);	// RHS vector

  	real[int] solCurlV(Vor.ndof);
  	solCurlV=ACurlV^-1*bCurlV;
  	Vor CurlV=solCurlV(0:Vor.ndof-1);

  	real Areai = Th.measure;					// Current Area
  	real Xcm = int2d(Th)(x)/Areai;		// Current Xcm
  	real Ycm = int2d(Th)(y)/Areai;		// Current Ycm
  	real Pxcm = int2d(Th)(p1)/Areai;	// Current P_x cm
  	real Pycm = int2d(Th)(p2)/Areai;	// Current P_y cm
  	real Vxcm = (Xcm-XcmP)/dt;			// Current V_x cm
  	real Vycm = (Ycm-YcmP)/dt;			// Current V_y cm
  	real DivTermsX = (int2d(Th)(x*DivV)-int2d(Th)(DivV)*Xcm)/Areai;	// Current value of the Div terms of V_x cm
  	real DivTermsY = (int2d(Th)(y*DivV)-int2d(Th)(DivV)*Ycm)/Areai;	// Current value of the Div terms of V_y cm

  	// Plot V
  	// if (verbosity) { // Show it always, regardless of the verbosity
  	Pola vABS = sqrt(V1(x,y)^2 + V2(x,y)^2);
  		plot(/*Th,[NDerP1,NDerP2],/*CurlV*/vABS, value = true, fill = true, nbiso = 64, wait = false, bb=[[Xcm-2,Ycm-2],[Xcm+2,Ycm+2]],
  				cmm = "t="+(dt*iterTime)+";  A/A0="+(Areai/Area0)+", (xcm,yxm)-(xcm0,yxm0)=("+(Xcm-Xcm0)+","+(Ycm-Ycm0)
  											+"), (vx,vy)=("+Vxcm+","+Vycm+")"
  											+"), A^-1(c/b)int p=("+(c/b)*Pxcm+","+(c/b)*Pycm+")");
  	// }

  	// Export data
  	if(iterTime % dsave == 0 && bsave==1){
  		//savemesh(Th,pathDir+"/LastMesh.msh"); 					// To load and restart the simualtion from the last configuration

  		// Save {x, y, p1, p2, V1, V2, DivV, CurlV, DivP, CurlP} on each vertex:
  		// Memory efficient method, but needs connectivity data to reconstruct the mesh
  		{	ofstream fileSolutions (pathDir+"/solutions/solRend"+(1000000+iterTime)+".txt");
  			fileSolutions.fixed;
  			int NbVertices = Th.nv;
  			fileSolutions << "# Positional Data" << endl
  										<< "# NumFields: " << 10 << "\tNumberVertices: " << NbVertices
  										<< "\titer: " << iterTime << "\ttime: " << dt*iterTime << endl
  										<< "# x\ty\tpx\tpy\tvx\tvy\tdiv(v)\tcurl(v)\tdiv(p)\tcurl(p)" << endl;
  			for (int i = 0; i < NbVertices; i++){
  				fileSolutions << Th(i).x                 <<" "<< Th(i).y                 <<" "
  											<< p1(Th(i).x,Th(i).y)     <<" "<< p2(Th(i).x,Th(i).y)     <<" "
  											<< V1(Th(i).x,Th(i).y)     <<" "<< V2(Th(i).x,Th(i).y)     <<" "
  											<< DivV(Th(i).x,Th(i).y)   <<" "<< CurlV(Th(i).x,Th(i).y)  <<" "
  											<< DivP(Th(i).x,Th(i).y)   <<" "<< CurlP(Th(i).x,Th(i).y)  <<endl ;//
  			}
  		}

  		{ ofstream fileTimeSeries (pathDir+"/timeSeries.csv", append);
  				fileTimeSeries	<< dt*iterTime   <<","<< Areai     <<","<< Xcm  <<","<< Ycm  <<","
  											 	<< Vxcm      <<","<< Vycm      <<","<< Pxcm <<","<< Pycm <<","
  												<< DivTermsX <<","<< DivTermsY <<"\n";
  		}

      // New save
      savemesh(Th,pathDir+"/meshes/meshRend"+(1000000+iterTime)+".msh");
  	}

  	// Move mesh
  	// real minT0 = checkmovemesh(Th, [x, y]); // to check for flipped triangles
  	// real minT = checkmovemesh(Th, [x+dt*V1,y+dt*V2]);
  	// cout << "Min triangle area before: "+minT0+" & after: "+minT<<endl;
  	Th = movemesh(Th,[x+dt*V1,y+dt*V2]);

  	// REMESHING - OPTIONAL (choose between A.1(a)-(c) for outer and between B.3(a)-(c) for inner)
  	// A.1. GET OUTER BOUNDARY VERTICES (b1)
  	real[int,int] b1(3,1); real l1=extractborder(Th,1,b1); // l1 is the permiter of b1
  	// A.2(a). LINEAR INTERPOLATION OF b1 (simple and robust, but bad for preserving shape integrity)
  	/* border Outer(t=0,1){ P=Curve(b1,t);label=1;}
  	int nO = round(obd*l1);  */						// new number of elements (prescribed density obd)
  	// A.2(b). VERTEX PRESERVING INTERPOLATION OF b1 (no remesh of outer boundary, probably best)
  	border Outer(t=0,1){ P=Curve(b1,b1(2,round(t*(b1.m-1)))/l1);label=1;}
  	int nO = b1.m-1; 								// keep number of elements
  	// A.2(c). SPLINE INTERPOLATION OF b1 (for remeshing outer boundary smoothly)
  	/*gslspline splineX(gslinterpakima, b1(2, :), b1(0, :)); 	// x(s) akima spline
  	gslspline splineY(gslinterpakima, b1(2, :), b1(1, :)); 	// y(s) akima spline
  	border Outer(t=0,l1){x=splineX(t);y=splineY(t);label=1;}
  	int nO = round(obd*l1);  		*/				// new number of elements (prescribed density obd)
  	// B.1. DISTANCE FUNCTION (d is the minimal distance to the boundary)
  	varf vong(B, d)= on(1,B=1);
  	real[int] ong=vong(0,Dh);
  	Dh B =1, d;
  	B[] = ong ? 0 : B[];
  	distance(Th,B,d[]);
  	// B.2. GET NEW INNER BOUNDARY VERTICES (ISO is the contour d==Lc)
  	real[int,int] ISO(3,1); int nc=isoline(Th,d,iso=ThickOutMesh,close=1,ISO,smoothing=ThickOutMesh/2.,ratio=1.e-0);
  	real l2=ISO(2,ISO.m-1); // l2 is the perimeter of ISO
  	// B.3(a). LINEAR INTERPOLATION OF ISO (simple and robust)
  	border Inner(t=0,1){ P=Curve(ISO,t);label=0;}
  	int nI = round(ibd*l2); 						// new number of elements (prescribed density ibd)
  	// B.3(b). VERTEX PRESERVING INTERPOLATION OF ISO (not ideal for this purpose, as we wish to impose uniform internal density)
  	/* border Inner(t=0,1){ P=Curve(ISO,ISO(2,round(t*(ISO.m-1)))/l2);label=2;}
  	int nI = ISO.m-1;   	*/						// keep number of elements
  	// B.3(c). SPLINE INTERPOLATION OF ISO (for remeshing inner boundary smoothly, probably overkill for this purpose)
  	/* gslspline splineXISO(gslinterpakima, ISO(2, :), ISO(0, :)); 	// x(s) akima spline
  	gslspline splineYISO(gslinterpakima, ISO(2, :), ISO(1, :)); 	// y(s) akima spline
  	border Inner(t=0,l2){x=splineXISO(t);y=splineYISO(t);label=2;}
  	int nI = round(ibd*l2);  */						// new number of elements (prescribed density ibd)
  	// C. BUILD NEW MESH
    try {
      Th=buildmesh(Outer(nO)+Inner(nI),fixedborder=1);
    	Th=change(Th,rmInternalEdges=1);
      Thb=emptymesh(Th);
    }
    catch(...){
      cout << "MESH ERROR: Simulation "+SimulName+" ended after "+iterTime+" iterations" << endl;
      break;
    }

    XcmP=Xcm; // Previous Xcm
    YcmP=Ycm; // Previous Ycm

    // if(Areai > rateMaxArea*Area0){
    //   cout << "WARNING: Simulation "+SimulName+" stopped after "+iterTime+" iterations due to large area" << endl;
    //   break;
    // }
  }
}
